<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Multi-Lane Traffic Network - Junction Control System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2332 0%, #2d3748 100%);
            min-height: 100vh; display: flex; flex-direction: column; align-items: center;
            padding: 20px; color: #333;
        }
        .header {
            background: rgba(255,255,255,0.95); backdrop-filter: blur(10px);
            border-radius: 20px; padding: 20px 40px; margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1); text-align: center;
        }
        .header h1 { color: #2d3748; font-size: 2.5rem; margin-bottom:10px; font-weight:700; }
        .header p { color: #4a5568; font-size: 1.1rem; }

        .container {
            background: rgba(255,255,255,0.95); backdrop-filter: blur(10px);
            border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            width:100%; max-width:1200px;
        }

        .controls { display:flex; gap:20px; margin-bottom:20px; flex-wrap:wrap; align-items:center; }
        .control-group { display:flex; flex-direction:column; gap:8px; }
        .control-group label { font-weight:600; color:#2d3748; font-size:0.9rem; }
        select, button {
            padding:12px 20px; border:2px solid #e2e8f0; border-radius:12px; font-size:1rem;
            transition: all 0.3s ease; background:white; cursor:pointer;
        }
        select:focus, button:focus { outline:none; border-color:#38a169; box-shadow:0 0 0 3px rgba(56,161,105,0.1); }
        button {
            background: linear-gradient(135deg,#38a169,#2f855a); color:white; border:none; font-weight:600;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(56,161,105,0.3); }
        #canvas {
            border: 3px solid #e2e8f0; border-radius:16px; background: linear-gradient(135deg,#f7fafc,#edf2f7);
            cursor: crosshair; display:block; margin: 0 auto; box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
        }

        .info-panel { margin-top:20px; background: linear-gradient(135deg,#f7fafc,#edf2f7); border-radius:16px; padding:20px; border:2px solid #e2e8f0; }
        .info-row { display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid #e2e8f0; }
        .info-row:last-child { border-bottom: none; }
        .info-label { font-weight:600; color:#2d3748; }
        .info-value { font-weight:500; color:#1a202c; }

        .legend { display:grid; grid-template-columns: repeat(auto-fit,minmax(200px,1fr)); gap:15px; margin-top:15px; }
        .legend-item { display:flex; align-items:center; gap:8px; font-size:0.85rem; color:#2d3748; }
        .legend-color { width:16px; height:16px; border-radius:50%; border:2px solid rgba(0,0,0,0.2); }

        .traffic-status { background: linear-gradient(135deg,#e6fffa,#b2f5ea); border-radius:12px; padding:15px; margin-top:15px; border:2px solid #38a169; }
        .traffic-status h3 { color:#2f855a; margin-bottom:10px; font-size:1.1rem; }
        .active-light { color:#38a169; font-weight:bold; background: rgba(56,161,105,0.1); padding:5px 10px; border-radius:8px; display:inline-block; }

        .junction-details { background: linear-gradient(135deg,#e6fffa,#b2f5ea); border-radius:12px; padding:15px; margin-top:10px; border:2px solid #38a169; }
        .junction-details h4 { color:#2f855a; margin-bottom:8px; }
        .light-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(150px,1fr)); gap:8px; margin-top:8px; }
        .light-status { padding:6px 12px; border-radius:6px; font-size:0.8rem; text-align:center; }
        .light-green { background:#c6f6d5; color:#22543d; border:1px solid #9ae6b4; }
        .light-red { background:#fed7d7; color:#742a2a; border:1px solid #fc8181; }

        @media (max-width:768px) {
            .header h1 { font-size:2rem; }
            .controls { flex-direction:column; align-items:stretch; }
            .control-group { width:100%; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸš¦ Multi-Lane Traffic Network</h1>
        <p>Advanced Junction Control System with Multiple Traffic Lights per Junction</p>
    </div>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="sourceSelect">Start Junction:</label>
                <select id="sourceSelect"><option value="">Select Start</option></select>
            </div>
            <div class="control-group">
                <label for="destSelect">End Junction:</label>
                <select id="destSelect"><option value="">Select End</option></select>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="findPathBtn">ðŸš€ Find Optimal Route</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="resetBtn">ðŸ”„ Reset Network</button>
            </div>
        </div>

        <canvas id="canvas" width="1140" height="600"></canvas>

        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">Total Travel Time:</span>
                <span class="info-value" id="totalDistance">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Route Junctions:</span>
                <span class="info-value" id="pathNodes">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Traffic System Status:</span>
                <span class="info-value" id="algorithmStatus">Ready</span>
            </div>

            <div class="traffic-status" id="trafficStatus" style="display:none;">
                <h3>ðŸš¦ Current Active Traffic Light:</h3>
                <p id="activeLight">None</p>
                <div class="junction-details" id="junctionDetails">
                    <h4>Junction Traffic Lights Status:</h4>
                    <div class="light-grid" id="lightGrid"></div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#4299e1"></div><span>Junction (Multi-Lane)</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#38a169"></div><span>Path Junction</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#ed8936"></div><span>Start Junction</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#e53e3e"></div><span>End Junction</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#00ff00"></div><span>Active Green Light</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#ff0000"></div><span>Red Light (Stopped)</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#718096"></div><span>Road Connection</span></div>
                <div class="legend-item"><div class="legend-color" style="background:#ffd700"></div><span>Active Route</span></div>
            </div>
        </div>
    </div>

    <script>
        class MultiLaneTrafficNetwork {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                this.outerNodes = []; // junctions
                this.innerNodes = []; // traffic lights (multiple per junction)
                this.edges = [];
                this.currentPath = [];
                this.sourceNode = null;
                this.destNode = null;
                this.activeTrafficLight = null;
                this.trafficCycleInterval = null;

                // Mock ambulance (moves along the path)
                this.ambulance = {
                    x: null, y: null, active: false, speed: 1.4, pathIndex: 0, target: null, prevJunction: null
                };

                this.setupEventListeners();
                this.generateRoadNetwork();
                this.animate();
            }

            setupEventListeners() {
                document.getElementById('findPathBtn').addEventListener('click', () => this.findShortestPath());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetNetwork());
                document.getElementById('sourceSelect').addEventListener('change', (e) => {
                    this.sourceNode = e.target.value ? parseInt(e.target.value) : null; this.updatePath();
                });
                document.getElementById('destSelect').addEventListener('change', (e) => {
                    this.destNode = e.target.value ? parseInt(e.target.value) : null; this.updatePath();
                });

                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }

            generateRoadNetwork() {
                this.outerNodes = [];
                this.innerNodes = [];
                this.edges = [];

                const junctionPositions = [
                    {x:150,y:120,label:'City Hospital'},
                    {x:350,y:80,label:'Junction B'},
                    {x:570,y:110,label:'Junction C'},
                    {x:780,y:90,label:'Junction D'},
                    {x:980,y:140,label:'General Hospital'},
                    {x:180,y:280,label:'Junction F'},
                    {x:400,y:250,label:'Junction G'},
                    {x:620,y:290,label:'Junction H'},
                    {x:840,y:270,label:'Junction I'},
                    {x:280,y:450,label:'St Mary Hospital'},
                    {x:520,y:480,label:'Junction K'},
                    {x:750,y:460,label:'Junction L'}
                ];

                junctionPositions.forEach((pos,i) => {
                    this.outerNodes.push({
                        id: i, x: pos.x, y: pos.y, label: pos.label.split(' ')[1], fullLabel: pos.label,
                        radius: 40, color: '#4299e1', inPath: false, glowIntensity: 0
                    });

                    const directions = [
                        {name: 'North', offsetX: 0, offsetY: -28, angle: 0},
                        {name: 'East',  offsetX: 28, offsetY: 0, angle: Math.PI/2},
                        {name: 'South', offsetX: 0, offsetY: 28, angle: Math.PI},
                        {name: 'West',  offsetX: -28, offsetY: 0, angle: 3*Math.PI/2}
                    ];

                    directions.forEach((dir, dirIndex) => {
                        this.innerNodes.push({
                            id: `${i}-${dirIndex}`,
                            junctionId: i,
                            parentId: i,
                            x: pos.x + dir.offsetX,
                            y: pos.y + dir.offsetY,
                            direction: dir.name,
                            label: `${pos.label.split(' ')[1]}-${dir.name}`,
                            radius: 8,
                            color: '#ff0000', // red default
                            isActive: false,
                            inPath: false,
                            blinkPhase: 0,
                            angle: dir.angle
                        });
                    });
                });

                const roadConnections = [
                    [0,1,15],[0,5,12],[1,2,18],[1,6,14],
                    [2,3,22],[2,7,16],[3,4,13],[3,8,19],
                    [4,8,11],[5,6,17],[5,9,25],[6,7,9],
                    [6,9,21],[6,10,28],[7,8,15],[7,10,12],
                    [7,11,23],[8,11,16],[9,10,8],[10,11,14],
                    [1,5,30],[2,6,26],[3,7,32],[4,11,29]
                ];

                roadConnections.forEach(([from,to,weight]) => {
                    this.edges.push({ from, to, weight, inPath:false, opacity:0.7, width:4 });
                });

                this.populateSelects();
            }

            populateSelects() {
                const sourceSelect = document.getElementById('sourceSelect');
                const destSelect = document.getElementById('destSelect');
                sourceSelect.innerHTML = `<option value="">Select Start Junction</option>`;
                destSelect.innerHTML = `<option value="">Select End Junction</option>`;
                this.outerNodes.forEach(node => {
                    sourceSelect.innerHTML += `<option value="${node.id}">${node.fullLabel}</option>`;
                    destSelect.innerHTML += `<option value="${node.id}">${node.fullLabel}</option>`;
                });
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.outerNodes.forEach(node => {
                    const distance = Math.hypot(x - node.x, y - node.y);
                    if (distance <= node.radius) node.glowIntensity = Math.min(node.glowIntensity + 0.1, 1);
                    else node.glowIntensity = Math.max(node.glowIntensity - 0.1, 0);
                });
            }

            dijkstra(start, end) {
                if (start === null || end === null) return null;
                const distances = {}; const previous = {}; const unvisited = new Set();
                this.outerNodes.forEach(node => { distances[node.id] = Infinity; previous[node.id] = null; unvisited.add(node.id); });
                distances[start] = 0;
                while (unvisited.size > 0) {
                    let current = null; let minDistance = Infinity;
                    for (let nodeId of unvisited) {
                        if (distances[nodeId] < minDistance) { minDistance = distances[nodeId]; current = nodeId; }
                    }
                    if (current === null || distances[current] === Infinity) break;
                    if (current === end) break;
                    unvisited.delete(current);
                    this.edges.forEach(edge => {
                        let neighbor = null;
                        if (edge.from === current) neighbor = edge.to;
                        else if (edge.to === current) neighbor = edge.from;
                        if (neighbor !== null && unvisited.has(neighbor)) {
                            const alt = distances[current] + edge.weight;
                            if (alt < distances[neighbor]) { distances[neighbor] = alt; previous[neighbor] = current; }
                        }
                    });
                }
                const path = []; let cur = end;
                if (previous[cur] === null && cur !== start) {
                    // maybe direct same node
                    if (cur === start) return { path: [start], distance: 0 };
                    return null;
                }
                while (cur !== null) { path.unshift(cur); cur = previous[cur]; }
                return path.length > 0 ? { path, distance: distances[end] } : null;
            }

            findShortestPath() {
                if (this.sourceNode === null || this.destNode === null) {
                    document.getElementById('algorithmStatus').textContent = 'Please select start and end junctions';
                    return;
                }
                if (this.sourceNode === this.destNode) {
                    document.getElementById('algorithmStatus').textContent = 'Start and end junctions cannot be the same';
                    return;
                }

                document.getElementById('algorithmStatus').textContent = 'Calculating optimal route...';
                setTimeout(() => {
                    const result = this.dijkstra(this.sourceNode, this.destNode);
                    if (result) {
                        this.currentPath = result.path;
                        this.updatePath();
                        this.startAmbulanceAlongPath();
                        document.getElementById('totalDistance').textContent = `${result.distance} minutes`;
                        document.getElementById('pathNodes').textContent = result.path.map(id => this.outerNodes[id].fullLabel).join(' â†’ ');
                        document.getElementById('algorithmStatus').textContent = 'Route found! Traffic control activated.';
                        document.getElementById('trafficStatus').style.display = 'block';
                        this.animatePathDiscovery();
                    } else {
                        document.getElementById('algorithmStatus').textContent = 'No route found';
                    }
                }, 150);
            }

            calculateDirectionOfTravel(fromJunctionId, toJunctionId) {
                const fromJunction = this.outerNodes[fromJunctionId];
                const toJunction = this.outerNodes[toJunctionId];
                const deltaX = toJunction.x - fromJunction.x;
                const deltaY = toJunction.y - fromJunction.y;
                const angle = Math.atan2(deltaY, deltaX);
                const degrees = (angle * 180 / Math.PI + 360) % 360;
                if (degrees >= 315 || degrees < 45) return 'East';
                else if (degrees >= 45 && degrees < 135) return 'South';
                else if (degrees >= 135 && degrees < 225) return 'West';
                else return 'North';
            }

            getDirectionalTrafficLights() {
                const directionalLights = [];
                for (let i = 0; i < this.currentPath.length; i++) {
                    const currentJunctionId = this.currentPath[i];
                    let direction = null;
                    if (i < this.currentPath.length - 1) {
                        const nextJunctionId = this.currentPath[i + 1];
                        direction = this.calculateDirectionOfTravel(currentJunctionId, nextJunctionId);
                    } else if (i > 0) {
                        const prevJunctionId = this.currentPath[i - 1];
                        direction = this.calculateDirectionOfTravel(prevJunctionId, currentJunctionId);
                    } else {
                        direction = 'North';
                    }
                    const trafficLight = this.innerNodes.find(light => light.junctionId === currentJunctionId && light.direction === direction);
                    if (trafficLight) directionalLights.push({ light: trafficLight, junctionId: currentJunctionId, direction, junctionLabel: this.outerNodes[currentJunctionId].fullLabel });
                }
                return directionalLights;
            }

            collectPathTrafficLights() {
                // kept for compatibility (not used heavily here)
                this.pathTrafficLights = this.getDirectionalTrafficLights().map(d => d.light.id);
            }

            startAmbulanceAlongPath() {
                if (!this.currentPath || this.currentPath.length === 0) return;
                // position ambulance at first junction
                const startId = this.currentPath[0];
                this.ambulance.x = this.outerNodes[startId].x;
                this.ambulance.y = this.outerNodes[startId].y;
                this.ambulance.active = true;
                this.ambulance.pathIndex = 0;
                this.ambulance.prevJunction = null;
                this.ambulance.target = this.currentPath.length > 1 ? this.currentPath[1] : null;
            }

            activateJunctionForAmbulance(junctionId) {
                // Determine direction based on where ambulance came from and is going to
                const idx = this.currentPath.indexOf(junctionId);
                let direction = 'North';
                if (idx !== -1) {
                    if (idx < this.currentPath.length - 1) {
                        direction = this.calculateDirectionOfTravel(junctionId, this.currentPath[idx + 1]);
                    } else if (idx > 0) {
                        direction = this.calculateDirectionOfTravel(this.currentPath[idx - 1], junctionId);
                    }
                }
                // Set all lights at this junction to red, then set the directional one to green
                this.innerNodes.forEach(light => {
                    if (light.junctionId === junctionId) { light.isActive = false; light.color = '#ff0000'; }
                });
                const directional = this.innerNodes.find(l => l.junctionId === junctionId && l.direction === direction);
                if (directional) { directional.isActive = true; directional.color = '#00ff00'; this.activeTrafficLight = directional; }
                this.updateTrafficLightGrid();
                document.getElementById('activeLight').innerHTML = `<span class="active-light">${this.outerNodes[junctionId].fullLabel} - ${direction} Direction - GREEN LIGHT ACTIVE</span>`;
            }

            updateTrafficLightGrid() {
                const lightGrid = document.getElementById('lightGrid');
                lightGrid.innerHTML = '';
                this.currentPath.forEach(junctionId => {
                    const junctionLabel = this.outerNodes[junctionId].fullLabel;
                    const junctionLights = this.innerNodes.filter(light => light.junctionId === junctionId);
                    const junctionDiv = document.createElement('div');
                    junctionDiv.innerHTML = `<strong>${junctionLabel}:</strong>`;
                    lightGrid.appendChild(junctionDiv);
                    junctionLights.forEach(light => {
                        const lightDiv = document.createElement('div');
                        lightDiv.className = light.isActive ? 'light-status light-green' : 'light-status light-red';
                        lightDiv.textContent = `${light.direction}: ${light.isActive ? 'GREEN (ACTIVE)' : 'RED'}`;
                        lightGrid.appendChild(lightDiv);
                    });
                });
            }

            animatePathDiscovery() {
                let index = 0;
                const animate = () => {
                    if (index < this.currentPath.length) {
                        const nodeId = this.currentPath[index];
                        this.outerNodes[nodeId].glowIntensity = 1;
                        if (index > 0) {
                            const prevNodeId = this.currentPath[index - 1];
                            const edge = this.edges.find(e => (e.from === prevNodeId && e.to === nodeId) || (e.from === nodeId && e.to === prevNodeId));
                            if (edge) { edge.inPath = true; edge.opacity = 1; edge.width = 6; }
                        }
                        index++; setTimeout(animate, 300);
                    }
                };
                animate();
            }

            updatePath() {
                // Reset visuals
                this.outerNodes.forEach(node => { node.inPath = false; node.color = '#4299e1'; });
                this.innerNodes.forEach(light => { light.inPath = false; light.color = '#ff0000'; light.isActive = false; });
                this.edges.forEach(edge => { edge.inPath = false; edge.opacity = 0.7; edge.width = 4; });

                if (this.sourceNode !== null) this.outerNodes[this.sourceNode].color = '#ed8936';
                if (this.destNode !== null) this.outerNodes[this.destNode].color = '#e53e3e';

                this.currentPath.forEach(nodeId => {
                    this.outerNodes[nodeId].inPath = true;
                    if (nodeId !== this.sourceNode && nodeId !== this.destNode) this.outerNodes[nodeId].color = '#38a169';
                    this.innerNodes.forEach(light => { if (light.junctionId === nodeId) light.inPath = true; });
                });

                for (let i = 0; i < this.currentPath.length - 1; i++) {
                    const from = this.currentPath[i], to = this.currentPath[i+1];
                    const edge = this.edges.find(e => (e.from === from && e.to === to) || (e.from === to && e.to === from));
                    if (edge) { edge.inPath = true; edge.opacity = 1; edge.width = 6; }
                }
            }

            resetNetwork() {
                this.currentPath = []; this.sourceNode = null; this.destNode = null; this.activeTrafficLight = null;
                if (this.trafficCycleInterval) clearInterval(this.trafficCycleInterval);
                document.getElementById('sourceSelect').value = '';
                document.getElementById('destSelect').value = '';
                document.getElementById('totalDistance').textContent = '-';
                document.getElementById('pathNodes').textContent = '-';
                document.getElementById('algorithmStatus').textContent = 'Ready';
                document.getElementById('trafficStatus').style.display = 'none';
                this.ambulance.active = false; this.ambulance.target = null;
                this.updatePath();
            }

            draw() {
                this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

                // roads
                this.edges.forEach(edge => {
                    const fromNode = this.outerNodes[edge.from], toNode = this.outerNodes[edge.to];
                    this.ctx.save(); this.ctx.globalAlpha = edge.opacity;
                    if (edge.inPath) { this.ctx.strokeStyle = '#ffd700'; this.ctx.shadowColor = '#ffd700'; this.ctx.shadowBlur = 8; }
                    else this.ctx.strokeStyle = '#718096';
                    this.ctx.lineWidth = edge.width; this.ctx.lineCap = 'round';
                    this.ctx.beginPath(); this.ctx.moveTo(fromNode.x, fromNode.y); this.ctx.lineTo(toNode.x, toNode.y); this.ctx.stroke(); this.ctx.restore();

                    // travel time labels
                    const midX = (fromNode.x + toNode.x)/2, midY = (fromNode.y + toNode.y)/2;
                    this.ctx.save(); this.ctx.font = 'bold 11px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                    const text = edge.weight + 'min'; const textWidth = this.ctx.measureText(text).width;
                    this.ctx.fillStyle = edge.inPath ? 'rgba(255,215,0,0.9)' : 'rgba(255,255,255,0.9)';
                    this.ctx.fillRect(midX - textWidth/2 - 4, midY - 8, textWidth + 8, 16);
                    this.ctx.strokeStyle = edge.inPath ? '#ffd700' : '#e2e8f0';
                    this.ctx.strokeRect(midX - textWidth/2 - 4, midY - 8, textWidth + 8, 16);
                    this.ctx.fillStyle = edge.inPath ? '#b45309' : '#4a5568';
                    this.ctx.fillText(text, midX, midY); this.ctx.restore();
                });

                // junctions
                this.outerNodes.forEach(node => {
                    this.ctx.save();
                    if (node.glowIntensity > 0 || node.inPath) {
                        this.ctx.shadowColor = node.color; this.ctx.shadowBlur = 20 + (node.glowIntensity * 15);
                    }
                    this.ctx.fillStyle = node.color; this.ctx.beginPath(); this.ctx.arc(node.x, node.y, node.radius, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.9)'; this.ctx.lineWidth = 4; this.ctx.stroke();
                    this.ctx.strokeStyle = 'rgba(0,0,0,0.2)'; this.ctx.lineWidth = 1; this.ctx.stroke();
                    this.ctx.restore();

                    // label
                    this.ctx.save(); this.ctx.fillStyle = 'white'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(node.label, node.x, node.y); this.ctx.restore();
                });

                // traffic lights (only for inPath junctions)
                this.innerNodes.forEach(light => {
                    if (!light.inPath) return;
                    this.ctx.save();
                    if (light.isActive) { this.ctx.shadowColor = light.color; this.ctx.shadowBlur = 20; }
                    this.ctx.fillStyle = light.color; this.ctx.beginPath(); this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.strokeStyle = light.isActive ? 'rgba(255,255,255,1)' : 'rgba(0,0,0,0.7)';
                    this.ctx.lineWidth = 2; this.ctx.stroke(); this.ctx.restore();

                    if (light.isActive) {
                        light.blinkPhase += 0.15;
                        if (Math.sin(light.blinkPhase) > 0.3) {
                            this.ctx.save(); this.ctx.fillStyle = 'rgba(255,255,255,0.9)'; this.ctx.beginPath(); this.ctx.arc(light.x, light.y, light.radius - 2, 0, Math.PI*2); this.ctx.fill(); this.ctx.restore();
                        }
                    }

                    // direction arrow
                    if (light.isActive) {
                        this.ctx.save(); this.ctx.translate(light.x, light.y); this.ctx.rotate(light.angle);
                        this.ctx.strokeStyle = 'white'; this.ctx.lineWidth = 2; this.ctx.beginPath();
                        this.ctx.moveTo(0, -light.radius + 3); this.ctx.lineTo(-3, -light.radius + 8);
                        this.ctx.moveTo(0, -light.radius + 3); this.ctx.lineTo(3, -light.radius + 8); this.ctx.stroke(); this.ctx.restore();
                    }

                    // small label
                    this.ctx.save(); this.ctx.fillStyle = light.isActive ? '#ffffff' : '#4a5568'; this.ctx.font = 'bold 8px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                    let labelX = light.x, labelY = light.y;
                    if (light.direction === 'North') labelY -= light.radius + 12;
                    if (light.direction === 'South') labelY += light.radius + 12;
                    if (light.direction === 'East') labelX += light.radius + 12;
                    if (light.direction === 'West') labelX -= light.radius + 12;
                    const labelText = light.direction.charAt(0);
                    const labelWidth = this.ctx.measureText(labelText).width;
                    this.ctx.fillStyle = light.isActive ? 'rgba(0,255,0,0.8)' : 'rgba(255,255,255,0.8)';
                    this.ctx.fillRect(labelX - labelWidth/2 - 2, labelY - 6, labelWidth + 4, 12);
                    this.ctx.fillStyle = light.isActive ? '#ffffff' : '#2d3748';
                    this.ctx.fillText(labelText, labelX, labelY);
                    this.ctx.restore();
                });

                // draw ambulance if active
                if (this.ambulance.active && this.ambulance.x !== null) {
                    this.ctx.save();
                    this.ctx.fillStyle = '#ffcb05';
                    this.ctx.beginPath();
                    this.ctx.arc(this.ambulance.x, this.ambulance.y, 10, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#333'; this.ctx.lineWidth = 1; this.ctx.stroke();
                    this.ctx.restore();
                }
            }

            stepAmbulance() {
                if (!this.ambulance.active || !this.currentPath || this.currentPath.length === 0) return;

                const idx = this.ambulance.pathIndex;
                const currJunctionId = this.currentPath[idx];
                const nextIdx = idx + 1;
                if (nextIdx >= this.currentPath.length) {
                    // reached destination â€” stop ambulance
                    this.ambulance.active = false;
                    document.getElementById('algorithmStatus').textContent = 'Ambulance reached destination';
                    return;
                }
                const nextJunctionId = this.currentPath[nextIdx];
                const targetNode = this.outerNodes[nextJunctionId];
                if (!targetNode) return;

                // move ambulance toward target
                const dx = targetNode.x - this.ambulance.x;
                const dy = targetNode.y - this.ambulance.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 1) return;
                const vx = (dx / dist) * this.ambulance.speed;
                const vy = (dy / dist) * this.ambulance.speed;
                this.ambulance.x += vx; this.ambulance.y += vy;

                // Check proximity to next junction -> activate node when within threshold
                const proximityThreshold = 55; // pixels
                if (Math.hypot(this.ambulance.x - targetNode.x, this.ambulance.y - targetNode.y) <= proximityThreshold) {
                    // activate the junction for ambulance direction
                    this.activateJunctionForAmbulance(nextJunctionId);
                }

                // If ambulance is very close to the target node center, step to next node
                if (Math.hypot(this.ambulance.x - targetNode.x, this.ambulance.y - targetNode.y) < 8) {
                    // mark passed junction lights back to red (cleanup)
                    const passedJunctionId = this.currentPath[idx];
                    this.innerNodes.forEach(light => { if (light.junctionId === passedJunctionId) { light.isActive = false; light.color = '#ff0000'; } });
                    this.ambulance.pathIndex = nextIdx;
                    // update target to next in path (or null if finished)
                    this.ambulance.target = this.currentPath.length > this.ambulance.pathIndex + 1 ? this.currentPath[this.ambulance.pathIndex + 1] : null;
                }
            }

            animate() {
                this.draw();
                // advance ambulance every frame
                this.stepAmbulance();
                this.animationFrame = requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize
        window.addEventListener('load', () => { new MultiLaneTrafficNetwork(); });
    </script>
</body>
</html>

